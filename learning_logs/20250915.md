# 새 DB 생성 방법
Unnamed -> 우클릭 -> 새로 생성 -> 새 데이터베이스

# 이상까지의 과정
1. MariawDB 설치
2. MariaDB에 default DBMS 프로그램인 HeidiSQL 설치(자동 설치)
3. database 생성 -> play_sql
4. play_sql 내부에 외부의 csv 파일을 가져오기
  -즉 이상의 부분은 이미 만들어진 데이터를 가지고 온 부분이라고 할 수 있습니다.
  - 이상의 과정에서 products.csv를 가져올 때 문제가 있었습니다.

  현재까지가 사전 준비 단계에 해당.

  # RDBMS 
  RDBMS(관계형 데이터베이스 관리 시스템 : Relational Database Management System)는 데이터를 관계형 모델을 기반으로 저장, 관리, 조작하는 소프트웨어 시스템. 관계형 모델은 데이터를 
  테이블(릴레이션) 형식으로 표현하며, 각 테이블은 행(row), 열(coloumn)으로 구성됩니다. RDBMS는 데이터 무결성 / 일관성 / 보안 등을 유지하면서 데이터를 효율적으로 관리하고 접근할 수 있게 보조함.

  ## 주요 특징
  1. 테이블 기반 구조 :
   - 데이터는 행(record)과 열(field)로 구성된 테이블에 저장됩니다.
   -각 테이블은 고유의 이름을 가지며, 데이터베이스 내에서 다른 테이블과 관계 맺을 수 있습니다.

   2. SQL 사용 : 
    -RDBMS는 데이터를 정의하고 조작하기 위해 SQL(Structed Query Language)을 사용합니다.
    - SQL은 데이터베이스 생성 / 테이블 생성 / 데이터 삽입 / 수정 / 삭제 / 조회 등의 조작을 위한 표준 언어입니다(근데 어떤 DBMS 쓰냐에 따라 dialect가 있음).

    3. 데이터 무결성 : 
      -데이터의 정확성과 일관성을 유지하기 위해 무결성 제약 조건(Primary Key, Foregin Key, Unique, Check 등)을 지원합니다. 특히 우리는 PK/FK 개념에 좀 집중할 예정입니다.
      -트랜젝션 처리(ACID 특성 : Atomicity / Consistency / Isolation / Durability) 를 통해 데이터 무결성을 보장합니다. - 기사 / 산기에 나옴.

    4. 관계 설정 : 
     - 테이블 간의 관계를 설정하여 데이터의 중복을 최소화하고, 데이터의 참조 무결성을 유지합니다.
     -관계의 유형으로 일대일(1:1) / 일대다(1:N) / 다대다(N:N)가 있습니다.

    5. 데이터 보안 : 
    -사용자 권한 관리 / 데이터 암호화 등을 통해 데이터베이스 보안을 강화합니다.
    -각 사용자는 데이터베이스 / 테이블 / column 단위로 접근 권한을 설정할 수 있습니다.

    ## RDBMS의 주요 기능 요약
    -데이터 정의 : 테이블 / 뷰 / 인덱스 / 스키마 등을 생성하고 관리
    -데이터 조작 : 데이터 삽입 / 수정 / 삭제 / 조회를 수행
    -데이터 제어 : 트랜젝션 관리 / 동시성 케어 / 회복 기능을 제공
    -데이터 보안 : 사용자 권한 설정 / 데이터 암호화 / 감사 로그 등을 지원

    # SQL 학습
    ## 정의
    - 구조화된 질문 언어 : RDMS 를 관리하기 위해 고안된 프로그래밍 언어.
    ### SQL은 어떻게 실행되는가?
    -컴퓨터에게 특정 데이터 정보를 가지고 오라고 명령할 때 필요한 정보:
      1. '무엇'을 가지고 와야하는지.
      2. '어디에서'가져와야 하는지.
    - 이상의 최소한의 정보들을 포함하여 컴퓨터가 알아들을 수 있고 / 또 사람이 알아볼 수 있는 형태로 구현한 것이 SQL.
      
    ```sql
    SELECT * FROM users;
    데이터를 가져와라(select) 전부 다(*) users라는 테이블에서(from users)
    끝(;)
    ```
    그리고 이상의 SQL문 실행하는 것을 우리나라에서는 _쿼리문을 실행했다_,_쿼리문을 날렸다_ 등의 표현을 씁니다. SQL 명령문을 컴퓨터에 전달했다는 의미이기도 합니다.

    저희는 SpringBoot 상황에서 Query Method라고 해서 SQL문과는 다르지만 Java내에서 method 형태로 명령어를 정의하고, 이것을 호출했을 때 MariaDB로 접속하여 특정 데이터를 가지고 오도록 제어할 예정입니다.

    ## SQL의 종류
    1. DML(Data Manipulation Language) : 데이터 조작 언어라는 뜻으로, 데이터 베이스의 내부 데이터를 관리하기 위한 기능. 주로 데이터를 조회하고 추가하고, 수정하거나 삭제하는 등의 기능을 수행하기 위하여 사용됨. SELECT / INSERT / UPDATE / DELETE 등이 있습니다.
      -그리고 이상의 생성 / 조회 / 수정 / 삭제를 CRUD라고도 합니다.
        -C : Create
        -R : Read
        -U : Update
        -D : Delete

    2. DDL(Data Definition Language) : 데이터 정의 언어라는 뜻으로, 관계형 데이터베이스 내의 저장 단위인 테이블(table)과 컬럼(column)을 정의하고 관리하는 명령어를 포함한다.
    저장 공간을 생성하고, 수정하거나 삭제하는 등의 주로 데이터 저장 공간을 결정하는 기능에 해당하며, 주요 명령어로는
      -CREATE
      -DROP
      -TRUNCATE 등이 있습니다.
    
    3. DCL(Data Control Language) : 관리 목적으로 주로 사용되며, 데이터베이스에 접근하려는 사용자의 권한을 관리하거나 보안과 관련된 기능을 담당한다. 주요 명령어로는 GRANT / REVOKE 등이 있습니다(시험에는 자주 나옵니다).

    4. TCL(Transaction Control Language) : 트랜잭션 제어 언어라는 의미로, 데이터베이스를 조작하는 명령 단위인 트랜젝션을 관리할 때 사용하는 기능(저는 은행을 경유하여 A고객에게서 B고객에게로 이체하는 과정을 설명할 때 얘기했습니다)을 담당한다. 주요 명령어로는 COMMIT / ROLLBACK 등이 있다.

    # 주요 용어
    1. 테이블(table) :
    - 관계형 데이터베이스 내에서 행과 열로 구성된 데이터를 저장하는 기본 단위.
    -엑셀을 하나의 데이터베이스라고 한다면 테이블은 엑셀 내에서의 sheet로 볼 수 있음. 
    -각 테이블은 고유한 식별자인 기본 키(Primary Key)를 가지고 있음.
    -기본 키는 테이블 내에서 각 행을 고유하기 식별하기 위해 사용.
    -테이블 간의 관계를 맺을 때는 외래 키(Foreign Key)를 사용.
    
    2. 컬럼(Column) : 
    -테이블에서 하나의 속성(attribute / Java에서는 field)에 해당하는 데이터를 저장하는 공간으로, 세로 줄인 열에 해당함.
    -각 컬럼에는 컬럼명 / 데이터 타입 / 크기 / 제약 조건 등을 정의할 수 있음.
    -Java에서 String studentName;이라고 했다면 데이터 타입과 컬럼명을 설정했다고 볼 수 있겠네요.

    3. 행(row) : 
    -테이블에서 가로줄 하나를 의미. Record라고도 부름
    -테이블에서 하나의 개별 데이터 단위를 나타내며, 특정 데이터가 저장되고 조회될 때 행 단위로 처리됨(Java에서는 객체가 됨)

    4. 기본 키(Primary Key / PK) :
    - 기본 키는 테이블에서 각 행(객체)을 고유하게 식별할 수 있는 값(html 태그에서의 id 값처럼 중복이 불가능합니다.)
    -기본 키는 하나가 아닌 여러 값의 조합으로 이루어질 수도 있으며, 이러한 기본 키는 테이블 내에서 중복되지 않는 유일한 값이어야 합니다.
    
    5. 외래 키(Foreign Key / FK) :
    -외래 키는 다른 테이블의 _기본 키_와 매칭되어 해당 테이블과의 관계를 정의함.
    -다른 테이블의 기본 키 값을 가져와서 컬럼을 구성하며 이후 테이블끼리 결합(JOIN 연산 수행)할 때 사용됨.
    -일반적으로 다른 테이블의 기본 키와 같은 데이터 타입과 크기(int/long)을 갖는다.

  # SQL문의 예시 포함 설명
  1. DDL
    - CREATE / ALTER / DROP
    -저희는 테이블을 클릭클릭으로 만들었지만 원래 CLI에서는 테이블 만드는 것도 명령어로 처리합니다. 이하는 그 예시
```sql
  CREATE TABLE users ( 
    id INT AUTO_INCREMENT PRIMARY KEY,    컬럼 # 1
    username VARCHAR(50) NOT NULL,        컬럼 # 2
    email VARCHAR(100) NOT NULL           컬럼 # 3
  );
```
이상을 Java로 풀게 되면
```java

public class User {
  @NonNull
  private int id;
  @NonNull
  private String username;
  @NonNull
  private String email;
}
```
과 유사하다고 보시면 되겠습니다.

2. DML 
- 주요 명령어 : INSERT / SELECT / DELETE / UPDATE 
- 에시
```sql
INSERT INTO users(username, email) VALUES ('홍길동', 'honggildong@test.com');
insert into 테이블명 (컬럼명1, 컬럼명2, ... ) values(컬럼명1의값, 컬럼명2의값, ...);

SELECT * FROM users;
select 컬럼명1, 컬럼명2, FROM 테이블명;

UPDATE users SET email = 'new_email@example.com' WHERE id = 1;
update 테이블명 SET 고치려는컬럼명 = '고치려는컬럼명의값' WHERE 조건식;

DELETE FROM users WHERE id = 1;
delete from 테이블명 WHERE 조건식;
```

# 원하는 데이터를 가져오고 필터링 하는 법
## 데이터 처리 4요소 : 생성 / 조회 / 수정 / 삭제
일단 저희는 현재 상황에서는 R에 집중할 예정입니다.
그래서 SQLD를 학습하시는 분들은 꼭꼭꼭꼭 추가학습이 요구됩니다.

### SELECT 
1. 사전에 미리 데이터들이 있다고 가정할 때, 가장 중요한 부분으로 '어떤 데이터를 어디에서' 가지고 올까와 관련된 구문. 

```sql
SELECT 'Hello SQL!';
```
이상의 결과값은 테이블명이 없고, Hello SQL이라는 컬럼에, Hello SQL! row가 생성된 것을 확인할 수 있습니다.
그래서 select는 그냥 _~을 보여줘_라는 의미로 받아들이시면 되겠습니다.

```sql
select 12 + 7;
```
그래서 현재의 특정 테이블과 관계 없는 상황에서 string 값을 사용한다든지 혹은 연산을 하는 것도 가능합니다.

기본 예제
결과 창의 첫 행에 Find/Insight/with SQL을 3개의 칸에 걸쳐 순서대로 출력해보겠습니다.
첫번째 컬럼명은 Find
두번째 컬럼명은 Insight
세번째 컬럼명은 with SQL이 될거고
row 역시 각각 Find/Insight/with SQL로 나오게됩니다.
```sql
SELECT 'Find', 'Insight', 'with SQL' ;
```
-다수의 row데이터를 순서대로 집어넣기 위해서는 `,`를 통해서 연결합니다.
```sql
SELECT 
	'Find' AS 'First',
	'Insight' AS 'Second',
	'with SQL' AS ' Third';
```
와 같은 방식으로 AS 명령어를 사용하게 되면 각 row에 대한 column명을 지정할 수 있습니다 - '저희는' 쓸 일 없습니다.


1. SELECT를 이용하여 28 + 891의 결과를 표시
2. SELECT를 이용하여 19 x 27의 결과를 표시 단, 컬럼명은 Result
3. SELECT를 이용하여 다음 세 가지 결과를 각각 다른 컬럼으로 결과창에 표시
-37 + 172 (단, 컬럼명은 Plus)
-25 x 78 (단, 컬럼명은 Times)
-I love SQL! (단, 컬럼명은 Result)
```
이상의 경우 String 데이터(MariaDB 기준으로는 VARCHAR의 경우)는 큰따옴표든 작은따옴표든 구분하지 않습니다(일반적으로는). 하지만 컬럼명을 지정할 때는 없어도 될 때가 있음.

### FROM
- 데이터가 저장된 위치를 알려주는 전치사. 
1.
```sql
SELECT * FROM users;
```
* \* : 와일드카드라고도 하고, 애스터리스크(asterisk)라고 하기도 합니다. 여기서는 _모든 컬럼_을 나타내는 표현입니다. 
```sql
SELECT *
  FROM products; 
```
으로 작성하더라도 결과값에서는 차이가 없습니다. 이상에서 알 수 있는 것은 html 태그와 마찬가지로 개행을 하는 것을 컴퓨터가 신경쓰지 않는다는 것을 의미합니다.
다만 개발자들끼리는 적절한 개행을 통해 가독성있는 SQL을 쓰는 것을 원칙으로 합니다.

제품 정보 테이블 products에서 첫 3개 행의 데이터만 가지고 오는 SQL (LIMIT에 주목)
```sql
SELECT * 
  FROM products
  LIMIT 3
  ;
```
아까까지는 전체 테이블을 all rows를 다 불러왔는데, 모든 정보를 조회하는 것을 full scan 이라는 표현을 씁니다. 그런데 테이블에 데이터가 엄청나게 많다면 그 데이터들을 불러오는 데에 컴퓨터가 많은 리소스를 쓰기 때문에 작업이 원활하지 않을 수 있어 full scan 자체는 지양되는 편입니다. 그래서 단순히 데이터의 상태를 파악하고 싶다면 LIMIT을 추가하여 일부 데이터만 확인하는 습관을 들이는 것이 좋습니다.
* MariaDB에서는 LIMIT을 쓰지만 Oracle / MySQL에서는 TOP 명령어를 사용.

연습 문제
products 테이블에서 제품 아이디(id), 제품명(name) 컬럼의 데이터들만 상위 30개만 추출하는 SQL문을 작성하시오.

```sql
SELECT id, name
  FROM products
  LIMIT 30
```

1. orderdetailes 테이블의 전체 컬럼을 표시하시오.
2. users에서 상위 7건의 데이터만 표시하시오.
3. orders에서 주문 아이디/ 회원 아이디/ 주문 일자 컬럼의 모든 데이터를 표시하시오.

```sql
SELECT * FROM orderdetails;
SELECT * FROM users LIMIT 7;
SELECT id,
```
### WHERE
-어떤 것을 고를까?
-SELECT / FROM을 통해서 어떤 테이블의 어떤 컬럼을 보여줄 지를 정했습니다. 거기에 LIMIT을 이용해서 상위에 있는 데이터들을 뽑아낼 수도 있었습니다.
-하지만 이상의 통제가 _특정 조건_을 만족시키는 row를 가지고 온다고 할 수는 없습니다.
-예를 들어, 특정 컬럼의 값이 A인 값만 가지고 온다든지, 여성인 회원의 정보만 가지고 온다든지, 마케팅 수신 동의를 한 사람들만 뽑아내서 그 사람들에게 광고 문자를 보낸다든지 등의 _조건_을 만족시키는 데이터만 조회하는 것 역시 매우 중요하다로 할 수 있음.

-SELECT에서는 테이블의 세로 부분인 컬럼을 제어했다면(어떤 컬럼을 보여줄 것인지), WHERE에서는 테이블의 가로 부분인 row를 제어하게 될겁니다.

회원 정보 테이블 users에서 거주 국가(country)가 한국(Korea)이면서, 동시에 마케팅 수신 동의(is_marketing_agree)를 동의(1)한 데이터를 추출하는 쿼리문
```sql
SELECT * 
	FROM users
	WHERE
		country = 'korea'
		and
		IS_marketing_agree = 1
	;
```
그렇다면, 회원 정보 테이블 users에서 거주 국가(Country)가 한국(Korea)이 아닌 데이터를 추출하는 쿼리문을 작성하시오.

회원 정보 테이블에서 거주국가가 한국이면서 id가 10인 회원만 추출하시오(결과값은 하나거나 아니면 없겠네요)

```

회원 정보 테이블 users에서 가입 일시(createed_at)가 2010-12-01부터 2011-01-01까지인 회원 정보를 출력하기
```sql
SELECT *
  FROM users
  WHERE created_at BETWEEN '2010-12-01' AND '2011-01-01'
  ;
```
이상의 SQL문에서 제가 안될 수도 있다고 한 이유는 created_at의 자료형이 DATE가 아니라 VARCHAR였는데 BETWEEN이 적용되냐의 문제 때문이었습니다. MariaDB에서는 처리되는 것을 확인했습니다.

BETWEEN A AND B : A와 B 사이
A - 시작 날짜
B - 종료 날짜

```sql
SELECT *
  FROM users
  WHERE created_at >= '2010-12-01'
  ;
```

그렇다면 회원 정보 테이블 users에서 가입일시가 2010-12-01부터 2011-03-01까지인 회원 정보를 BETWEEN을 사용하지 않고 출력하시오(이상의 쿼리문을 참조하여).
```sql

```
회원 정보 테이블 users에서 거주 국가(country)가 Korea거나 UK거나 USA인 회원 정보만 추출하시오.
```sql
SELECT * FROM users
	WHERE country = 'Korea' OR country = 'UK' OR country = 'USA' ;
```
SELECT / FROM / WHERE / BETWEEN A AND B / AND / OR
까지 학습했는데 IN 배울겁니다.
이상의 SQL문을 IN 전치사를 적용하면
```sql
SELECT * FROM users
  WHERE country IN ('Korea','UK', 'USA')
  ;
```
python에서도 for / if문 쓸 때 확인하셨겠지만 IN의 의미는 `IN 다음에 나오는 iterable 내에 있는`이라는 뜻이 되겠습니다.

그래서 WHERE은 굳이 프로그래밍 언어에 따르면 조건식이라는 표현에서도 알 수 있듯이 if로 보셔도 무방하겠습니다.

그렇다면 python에서 배운 것을 떠올려서, 회원 정보 테이블 uses에서 country가 Korea / UK / USA가 아닌 회원 정보만 추출하려면 어떡할지 고민해보시오.(노가다로 country IN ('Japan', 'France'... )하라는게 아닙니다).
```sql
SELECT * FROM users
  WHERE country NOT IN ('Korea', 'UK', 'USA')
  ;
```
그래서 python에서와 마찬가지로 NOT연산자와 !가 둘 다 존재합니다.
NOT IN : ~중에 있지 않은

예제 문제
users에서 country 이름이 _S로 시작하는_ 회원 정보 추출하기
```sql
SELECT * FROM users WHERE country LIKE 'S%';
```
이상의 SQL문이 중요한 이유가 뭐냐면 저희가 게시판 같은거 할 때 filtering을 할 때가 있습니다. 제목에 'SQL'이 포함되어있는지 뭐 이런거요.
```sql
SELECT * FROM articles WHERE title LIKE '%SQL%';
```
제목 + 내용에도 '쿼리'가 포함되어있는지
```sql
SELECT * FROM articles WHERE title LIKE '%쿼리%' OR content LIKE '%쿼리%';
```

- `LIKE` :
 - 기존에 사용한 = 과 != 연산자는 컬럼값이 조건 값과 _정확히_ 일치하는 것만 가져올 수 있는 반면에, LIKE는 WHERE에 조건문을 작성할 때 일부 패턴에 일치하는 데이터도 가지고 올 수 있다는 점에서 매우 유용합니다.

 - LIKE 뒤의 '작은따옴표/큰따옴표' 내에서는 와일드카드를 사용할 수 있는데, 특히 LIKE가 오면 와일드카드 오겠다고 생각하시면 됩니다.

 -와일드카드 `%`는 0개 이상의 임의의 문자열을 의미하는 메타 문자로 사용됩니다.
  그러면 `S%`의 의미는 첫 문자는 S인데 뒤에 몇 개의 문자가 올지는 모르겠지만 S 뒤에 여러 개의 문자가 나열된 결과값을 전부 다 가지고 온다고 해석할 수 있겠습니다.

  - `_` : 한개의 임의의 문자를 나타냄.

  - `[]` : 대괄호 내의 문자 집합 중 일치하는 1개의 문자를 나타냄.

회원 정보 테이블 users에서 거주 국가 이름이 S로 시작하지 않는 회원 정보를 추출하시오.

```sql
SELECT * FROM users WHERE country NOT LIKE 'S%';
```
- WHERE은 조건을 만족하는 데이터만 가져오도록 제한한다(row 기준이라는 측면에서 SELECT와 차이가 있습니다.)
- FROM이 끝난 뒤에 위치한다(추후 설명 예정 / SQL문은 순서가 중요)
- WHERE을 사용하여 필터링하면 조건에 맞는 row만 선택되어 출력된다. 즉, 가로추겡 해당하는 행 단위로 필터링이 적용되며, WHERE을 통해 조건을 지정하면 해당 조건에 부합하는 행만 출력된다.Springboot와 연결되면 부합하는 객체만 출력.
  `WHERE country = 'Korea'와 같은 방식
- 한 가지 이상의 조건을 개수 제한 없이 동시에 사용할 수 있으며, 개별 조건을 연결할 때는 논리 연산자인 AND / OR을 사용한다.
- IN / LIKE / %의 개념도 필수적으로 알아둘 수 있도록 한다.

## 연습 문제
1. 회원 정보 테이블에서 거주 국가가 멕시코인 회원의 정보를 추출하라. 단, 가입일시, 연락처, 거주 도시, 거주 국가 컬럼만 출력할 것.
```sql
SELECT created_at, phone, city, country FROM users WHERE country = 'Mexico';


2. 제품 정보 테이블 orders에서 제품 아이디가 20 이하이고, 정상 가격(price)는 30 이상인 제품의 정보를 추출하라. 단, 기존 컬럼을 모두 출력하고, 정상 가격에서 얼마나 할인되었는지(price - discount_price)를 discount_amount라는 컬럼명으로 추가하라.
```sql
SELECT *, price - discount_price AS discount_amount FROM products;
T id, NAME, price, discount_price, price_discount_price AS discount_amount FROM products WHERE id <= 20 AND price >= 30;


3. users에서 거주 국가가 한국도, 캐나다도, 벨기에(Belgium) 도 아닌 회원의 정부를 모두 추출하라. (OR 연산자 사용하지 않고 출력)


4. products에서 제품명이 N으로 시작하는 제품의 정보를 추출하라. (단, id/ name/ price 컬럼만 출력할 것)
```

```sql
SELECT id, name, price FROM products WHERE name LIKE 'N%';

```


5. 주문 정보 테이블 orders에서 주문 일자가 2015-07-01부터 2015-10-31까지가 아닌 정보만 추출하시오.
```sql
SELECT * FROM orders WHERE order_date NOT BETWEEN '2015-07-01' AND '2015-10-31';

```

SELECT * FROM users 
	WHERE country NOT IN ('Korea', 'Canada', 'Belgium')
	;

TABLE products 
 	WHERE id INT N 

SELECT * FROM orders '2015-07-01'
```

## ORDER BY
- '어떤 순서로 볼까?' 
- 특정 컬럼을 기준으로 오름차순 / 내림차순으로 할 것인지를 결정짓는겁니다.
예시 
```sql
SELECT * FROM users
  ORDER BY id ASC
  ;
```
이상의 SQL문 해석은 users 테이블의 전체 컬럼을 다 가지고 오는데, 그중 id 컬럼을 기준으로 오름차순하여 출력할 것.

-사실 GUI 형태로 HeidiSQL을 쓸 경우 일일이 SQL문을 쓸 필요 없이 마우스 딸깍딸깍해서 오름차순 내림차순 하는 것은 쉽습니다.
다만 학부생 시절에 DBMS 과목을 들으셨다면 GUI 안쓰고 무슨 어미널 같은데서 SQL문 조작하신 분도 있으실텐데, 그때는 하나하나 SQL문을 작성해서
오름차순 / 내림차순도 제어해줬어야만 했습니다.

```sql
SELECT * FROM users ORDER BY city DESC;
```
거주 도시 기준으로 내림 차순 정렬한겁니다.
- 참고 : 아스키 코드 기준으로 오름차순 / 내림차순 정렬됩니다.

연습 문제
users에서 가입 일시 기준으로 오름차순 정렬하여 전체 컬럼 출력하시오.
```sql

```
users에서 가입 일시 기준으로 내림차순 정렬하여 전체 컬럼 출력하시오.
```sql
SELECT * FROM users ORDER BY created_at DESC;
```
ORDER BY는 컬럼명을 몰라도 정렬을 수행하는 게 가능합니다. 예를 들어서 전체 테이블의 첫 번째 컬럼은 웬만하면 고유식별자인 id입니다. 그런데 테이블에 따라서 order_id일 때도 있고 그냥 id일 때도 있는 등
여러분이 일하는 곳 따라서 다르게 작성됩니다. 하지만 PK가 첫 번째 테이블인 경우가 많다보니까

```
SELECT * FROM users
  ORDER BY 1 ASC;
```
와 같은 방식의 SQL문 작성이 가능합니다.

연습 문제 
users에서 username / phone / city / country / id 컬럼을 순서대로 출력하는데, 결과를 첫 번째 컬럼 기준으로 오름 차순 정렬하시오.
```sql
SELECT username, phone, city, country, id FROM users ORDER BY 1 ASC;
```
이상의 SQL문을 기준으로 했을 떄는 id를 기준으로 한 것이 아니라 username을 기준으로 오름차순이 적용되었음을 확인할 수 있습니다. 그렇다면 여러분들은 SELECT 다음에 나오는 컬럼의 순서가 데이터의 추출에 영향을 끼칠 수 있음을 알 수 있을 겁니다. 

그래서 사실 개발자들끼리 할 때는 ORDER BY 다음에 숫자 쓰는걸 지양하기도 합니다.

예시 문제
users에서 city / id 컬럼만 출력하는데, 거주 도시 기준으로는 내림차순, 회원 아이디 기준으로는 오름차순 정렬하겠습니다.(ORDER BY에 두 가지 조건 걸려있음).

```sql
SELECT city, id FROM users ORDER BY city DESC, id ASC;
```
ORDER BY 뒤에 복수의 정렬 조건이 나열 될 때에는 `,`를 기준으로 작성하면 됩니다. 그러면 출력 결과를 보기 전에 해석하기로는 city 컬럼 먼저, id 컬럼이 뒤에 나오는데, city를 기준으로 내림차순을 먼저하고, 만약에 같은 도시들이 중복된다면 id기준으로 오름차순한다는 의미가 됩니다.

연습 문제
1. 제품 정보 테이블에서 정상 가격이 비싼 제품부터 순서대로 모든 컬럼을 출력하시오.
```sql
SELECT * FROM products ORDER BY price DESC;
```

2. 주문 정보 테이블에서 주문 일자 기준으로 최신 순으로 정렬하여 모든 컬럼을 출력하시오.
```sql
SELECT * FROM orders ORDER BY order_date DESC;
```

3. 주문 상세 정보 테이블 orderdetails에서 먼저 제품 아이디(product_id)를 기준으로 내림차순 정렬하고, 같은 제품 아이디 내에서는 판매 수량(quantity) 값을 기준으로 오름차순 정렬하여 모든 컬럼을 출력하시오.

```sql
SELECT * FROM orderdetails ORDER BY product_id DESC, quantity ASC;
```

# SQL 실무 예시
SELECT / FROM / WHERE / ORDER BY
-배달 서비스에서 어떻게 추출하는가?
1. 2023-08-01에 주문한 내역 중 쿠폰 할인이 적용된 내역만 추출
```sql
SELECT * FROM 주문정보
  WHERE 주문일자 = '2023-08-01'
    AND 쿠폰할인금액 > 0;
```
2. 마포구에서 1인분 배달이 가능한 배달 음식점만 추출
```sql
SELECT * FROM 음식점정보
 WHERE 지역 = '마포구'
   AND 1인분가능여부 = 1;
```
여기서 0 / 1은 boolean 자료형이라고 생각하면 되겠습니다.
예시라서 적는 참조 사항 : 오늘 일자를 가져오는 부분과 윽정 일자에서 한 달을 차감하는 등의 함수가 DB 별로 다르게 설정되어있으므로 참고만 하시기 바랍니다.

-전자책 서비스에서의 적용 사례
1. 출간된지 한 달 이내인 신간 중 페이지 수가 200 이상인 도서만 추출
```sql
SELECT * FROM 도서정보
  WHERE 출간일자 >= (오늘일자 - 한 달)
    AND 페이지수 >= 200
    ;
```
2. 최근 한 달 이내에 도서 구독 멤버십에 가입한 회원 수 추출
```sql
SELECT * FROM 회원정보
  WHERE 가입일자 >= (오늘일자 - 한 달)
  AND 멤버십가입여부 = 1
  ;
```
ADSP - R

포트넘버 3310
비밀번호 1234